/*
    Copyright (C) 2009 Johannes Schindelin (johannes.schindelin@gmx.de)

    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation; either version
    3 of the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#include "ffmpeg.h"

#ifdef HAVE_FFMPEG
extern "C" {
#define INT64_C(c) c##ll
#include "libavutil/avutil.h"
#include "libavcodec/avcodec.h"
#include "libavformat/avformat.h"
#include "libswscale/swscale.h"
}
#endif

class FrameExporter {
protected:
    SDL_Surface *surface;
    char *pixels;
    size_t rowstride;

public:
    FrameExporter();
    virtual ~FrameExporter() {}
    virtual void initialize();
    void dump();
    virtual void dumpImpl();
};

FrameExporter::FrameExporter()
    : surface(NULL), pixels(NULL), rowstride(0)
{ }

void FrameExporter::initialize() {
}

/* Write out all frames to stdout in PPM format */
void FrameExporter::dump() {
    if(!surface) {
        surface = SDL_GetVideoSurface();
	rowstride = surface->w * 3;
	pixels = (char *)malloc((surface->h + 1) * rowstride);
        initialize();
    }
    glReadPixels(0, 0, surface->w, surface->h,
        GL_RGB, GL_UNSIGNED_BYTE, pixels);
    dumpImpl();
}

void FrameExporter::dumpImpl() {
    printf("P6\n# Generated by Gource\n%d %d\n255\n",
        surface->w, surface->h);
    for(int y = surface->h - 1; y >= 0; y--) {
        fwrite(pixels + y * rowstride, rowstride, 1, stdout);
    }
}

#ifdef HAVE_FFMPEG
class FFMPEGExporter : public FrameExporter {

public:
	FFMPEGExporter(std::string filename);
	~FFMPEGExporter();
	void initialize();
	void dumpImpl();

protected:
	AVFrame *picture, *tmp_picture;
	uint8_t *video_outbuf;
	int frame_count, video_outbuf_size;
	std::string filename;
	AVOutputFormat *fmt;
	AVFormatContext *oc;
	AVStream *video_st;
	double video_pts;
        struct SwsContext *img_convert_ctx;

	AVStream *add_video_stream(AVFormatContext *oc, enum CodecID codec_id,
			int width, int height);
	AVFrame *alloc_picture(enum PixelFormat pix_fmt, int width, int height);
	void open_video(AVFormatContext *oc, AVStream *st);
	void write_video_frame(AVFormatContext *oc, AVStream *st);
	void close_video(AVFormatContext *oc, AVStream *st);
};

AVStream *FFMPEGExporter::add_video_stream(AVFormatContext *oc,
		enum CodecID codec_id, int width, int height)
{
    AVCodecContext *c;
    AVStream *st;

    st = av_new_stream(oc, 0);
    if (!st) {
        fprintf(stderr, "Could not alloc stream\n");
        exit(1);
    }

    c = st->codec;
    c->codec_id = codec_id;
    c->codec_type = CODEC_TYPE_VIDEO;

    /* put sample parameters */
    c->bit_rate = 3400000;
    /* resolution must be a multiple of two */
    c->width = width;
    c->height = height;
    /* time base: this is the fundamental unit of time (in seconds) in terms
       of which frame timestamps are represented. for fixed-fps content,
       timebase should be 1/framerate and timestamp increments should be
       identically 1. */
    c->time_base.den = 25;
    c->time_base.num = 1;
    c->gop_size = 12; /* emit one intra frame every twelve frames at most */
    c->pix_fmt = PIX_FMT_YUV420P;
    if (c->codec_id == CODEC_ID_MPEG2VIDEO) {
        /* just for testing, we also add B frames */
        c->max_b_frames = 2;
    }
    if (c->codec_id == CODEC_ID_MPEG1VIDEO){
        /* Needed to avoid using macroblocks in which some coeffs overflow.
           This does not happen with normal video, it just happens here as
           the motion of the chroma plane does not match the luma plane. */
        c->mb_decision=2;
    }
    // some formats want stream headers to be separate
    if(oc->oformat->flags & AVFMT_GLOBALHEADER)
        c->flags |= CODEC_FLAG_GLOBAL_HEADER;

    return st;
}

AVFrame *FFMPEGExporter::alloc_picture(enum PixelFormat pix_fmt,
		int width, int height)
{
    AVFrame *picture;
    uint8_t *picture_buf;
    int size;

    picture = ::avcodec_alloc_frame();
    if (!picture)
        return NULL;
    size = avpicture_get_size(pix_fmt, width, height);
    picture_buf = (uint8_t *)av_malloc(size);
    if (!picture_buf) {
        av_free(picture);
        return NULL;
    }
    avpicture_fill((AVPicture *)picture, picture_buf,
                   pix_fmt, width, height);
    return picture;
}

void FFMPEGExporter::open_video(AVFormatContext *oc, AVStream *st)
{
    AVCodec *codec;
    AVCodecContext *c;

    c = st->codec;

    /* find the video encoder */
    codec = ::avcodec_find_encoder(c->codec_id);
    if (!codec) {
        fprintf(stderr, "codec not found\n");
        exit(1);
    }

    /* open the codec */
    if (::avcodec_open(c, codec) < 0) {
        fprintf(stderr, "could not open codec\n");
        exit(1);
    }

    video_outbuf = NULL;
    if (!(oc->oformat->flags & AVFMT_RAWPICTURE)) {
        /* allocate output buffer */
        /* XXX: API change will be done */
        /* buffers passed into lav* can be allocated any way you prefer,
           as long as they're aligned enough for the architecture, and
           they're freed appropriately (such as using av_free for buffers
           allocated with av_malloc) */
        video_outbuf_size = 200000;
        video_outbuf = (uint8_t *)::av_malloc(video_outbuf_size);
    }

    /* allocate the encoded raw picture */
    picture = alloc_picture(c->pix_fmt, c->width, c->height);
    if (!picture) {
        fprintf(stderr, "Could not allocate picture\n");
        exit(1);
    }

    /* if the output format is not RGB24, then a temporary RGB24
       picture is needed too. It is then converted to the required
       output format */
    tmp_picture = NULL;
    if (c->pix_fmt != PIX_FMT_RGB24) {
        tmp_picture = alloc_picture(PIX_FMT_RGB24, c->width, c->height);
        if (!tmp_picture) {
            fprintf(stderr, "Could not allocate temporary picture\n");
            exit(1);
        }
    }
}

void FFMPEGExporter::write_video_frame(AVFormatContext *oc, AVStream *st)
{
    int out_size, ret;
    AVCodecContext *c;
    static struct SwsContext *img_convert_ctx;

    c = st->codec;

    if (oc->oformat->flags & AVFMT_RAWPICTURE) {
        /* raw video case. The API will change slightly in the near
           futur for that */
        AVPacket pkt;
        ::av_init_packet(&pkt);

        pkt.flags |= PKT_FLAG_KEY;
        pkt.stream_index= st->index;
        pkt.data= (uint8_t *)(tmp_picture ? tmp_picture : picture);
        pkt.size= sizeof(AVPicture);

        ret = ::av_interleaved_write_frame(oc, &pkt);
    } else {
        /* encode the image */
        out_size = ::avcodec_encode_video(c, video_outbuf, video_outbuf_size, picture);
        /* if zero size, it means the image was buffered */
        if (out_size > 0) {
            AVPacket pkt;
            ::av_init_packet(&pkt);

            if (c->coded_frame->pts != AV_NOPTS_VALUE)
                pkt.pts= ::av_rescale_q(c->coded_frame->pts, c->time_base, st->time_base);
            if(c->coded_frame->key_frame)
                pkt.flags |= PKT_FLAG_KEY;
            pkt.stream_index= st->index;
            pkt.data= video_outbuf;
            pkt.size= out_size;

            /* write the compressed frame in the media file */
            ret = ::av_interleaved_write_frame(oc, &pkt);
        } else {
            ret = 0;
        }
    }
    if (ret != 0) {
        fprintf(stderr, "Error while writing video frame\n");
        exit(1);
    }
    frame_count++;
}

void FFMPEGExporter::close_video(AVFormatContext *oc, AVStream *st)
{
    ::avcodec_close(st->codec);
    ::av_free(picture->data[0]);
    ::av_free(picture);
    if (tmp_picture) {
        av_free(tmp_picture->data[0]);
        av_free(tmp_picture);
    }
    av_free(video_outbuf);
}

FFMPEGExporter::FFMPEGExporter(std::string movie_file_name)
    : FrameExporter(), filename(movie_file_name), img_convert_ctx(NULL)
{
    /* initialize libavcodec, and register all codecs and formats */
    av_register_all();
}

FFMPEGExporter::~FFMPEGExporter()
{
    /* write the trailer, if any.  the trailer must be written
     * before you close the CodecContexts open when you wrote the
     * header; otherwise write_trailer may try to use memory that
     * was freed on av_codec_close() */
    av_write_trailer(oc);

    /* close each codec */
    if (video_st)
        close_video(oc, video_st);

    /* free the streams */
    for(int i = 0; i < oc->nb_streams; i++) {
        av_freep(&oc->streams[i]->codec);
        av_freep(&oc->streams[i]);
    }

    if (!(fmt->flags & AVFMT_NOFILE)) {
        /* close the output file */
        url_fclose(oc->pb);
    }

    /* free the stream */
    av_free(oc);
}

void FFMPEGExporter::initialize() {
    /* auto detect the output format from the name. default is
       mpeg. */
    fmt = guess_format(NULL, filename.c_str(), NULL);
    if (!fmt) {
        printf("Could not deduce output format from file extension: using MPEG.\n");
        fmt = guess_format("mpeg", NULL, NULL);
    }
    if (!fmt) {
        fprintf(stderr, "Could not find suitable output format\n");
        exit(1);
    }

    /* allocate the output media context */
    oc = avformat_alloc_context();
    if (!oc) {
        fprintf(stderr, "Memory error\n");
        exit(1);
    }
    oc->oformat = fmt;
    snprintf(oc->filename, sizeof(oc->filename), "%s",
		    filename.c_str());

    /* add the video stream using the default format codec
       and initialize the codec */
    video_st = NULL;
    if (fmt->video_codec != CODEC_ID_NONE) {
        video_st = add_video_stream(oc, fmt->video_codec,
			surface->w, surface->h);
    }

    /* set the output parameters (must be done even if no
       parameters). */
    if (av_set_parameters(oc, NULL) < 0) {
        fprintf(stderr, "Invalid output format parameters\n");
        exit(1);
    }

    dump_format(oc, 0, filename.c_str(), 1);

    /* now that all the parameters are set, we can open the audio and
       video codecs and allocate the necessary encode buffers */
    if (video_st)
        open_video(oc, video_st);

    /* open the output file, if needed */
    if (!(fmt->flags & AVFMT_NOFILE)) {
        if (url_fopen(&oc->pb, filename.c_str(), URL_WRONLY) < 0) {
            fprintf(stderr, "Could not open '%s'\n", filename.c_str());
            exit(1);
        }
    }

    /* write the stream header, if any */
    ::av_write_header(oc);
}

void FFMPEGExporter::dumpImpl() {
    AVCodecContext *c = video_st->codec;

    // flip vertically
    for (int j = 0; j < surface->h; j++)
	memcpy((void *)&tmp_picture->data[0][j * rowstride],
            (void *)&pixels[(surface->h - 1 - j) * rowstride],
	    rowstride);

        if (c->pix_fmt != PIX_FMT_RGB24) {
            /* as we only generate a RGB24 picture, we must convert it
               to the codec pixel format if needed */
            if (img_convert_ctx == NULL) {
                img_convert_ctx = sws_getContext(c->width, c->height,
                                                 PIX_FMT_RGB24,
                                                 c->width, c->height,
                                                 c->pix_fmt,
                                                 SWS_BICUBIC, NULL, NULL, NULL);
                if (img_convert_ctx == NULL) {
                    fprintf(stderr, "Cannot initialize the conversion context\n");
                    exit(1);
                }
            }
            sws_scale(img_convert_ctx, tmp_picture->data, tmp_picture->linesize,
                      0, c->height, picture->data, picture->linesize);
        }
	video_pts = (double)video_st->pts.val * video_st->time_base.num
		/ video_st->time_base.den;

	/* write interleaved audio and video frames */
	write_video_frame(oc, video_st);
}
#endif

static FrameExporter *gFrameExporter = NULL;

void initializeStdoutExporter() {
	gFrameExporter = new FrameExporter();
}

#ifdef HAVE_FFMPEG
void initializeMovieExporter(std::string filename) {
	gFrameExporter = new FFMPEGExporter(filename);
}
#endif

void dumpFrame() {
    if (gFrameExporter)
        gFrameExporter->dump();
}

void cleanupFrameExporter() {
	if (gFrameExporter)
		delete gFrameExporter;
}
